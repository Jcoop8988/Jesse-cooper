@using Radzen.Blazor.Rendering
@typeparam TItem
@inherits RadzenChartComponentBase
@implements IRadzenSeriesOverlay

@code {
    [Parameter]
    public CoordinateSystem? CoordinateSystem { get; set; }

    [Parameter]
    public TItem Data { get; set; }

    [Parameter]
    public string Text { get; set; }

    [Parameter]
    public double OffsetX { get; set; }

    [Parameter]
    public double OffsetY { get; set; }

    [Parameter]
    public string Class { get; set; }

    [Parameter]
    public bool Visible { get; set; } = true;

    CartesianSeries<TItem> series;
    [CascadingParameter]
    protected CartesianSeries<TItem> Series 
    { 
        get
        {
            return series;
        }
        set
        {
            if (!value.Overlays.Contains(this))
            {
                series = value;
                series.Overlays.Add(this);
            }
        }
    }

    public RenderFragment Render(ScaleBase categoryScale, ScaleBase valueScale)
    {
        double x = series.TooltipX(Data);
        double y = series.TooltipY(Data);

        var coordinateSystem = CoordinateSystem ?? series.CoordinateSystem;
        switch (coordinateSystem)
        {
            case Radzen.CoordinateSystem.Cartesian:
                x += OffsetX;
                y += OffsetY;
                break;

            case Radzen.CoordinateSystem.Polar:
                double orgX;
                double orgY;
                if (series is RadzenPieSeries<TItem>)
                {
                    var pieSeries = series as RadzenPieSeries<TItem>;
                    orgX = pieSeries.CenterX;
                    orgY = pieSeries.CenterY;
                }
                else
                {
                    orgX = x;
                    orgY = y;
                }

                x -= orgX;
                y -= orgY;

                // find angle and add offset
                var phi = Math.Atan2(y, x);
                phi += Polar.ToRadian(OffsetY % 360);

                // find radius
                var hyp = Math.Sqrt(x * x + y * y) + OffsetX;

                // move along the radius and rotate
                x = orgX + hyp * Math.Cos(phi);
                y = orgY + hyp * Math.Sin(phi);                    
                break;
        }

        Point pt = new Point() { X = x, Y = y };
        return 
        @<g>
            <Text @key="@($"{pt}-{Text}-{Chart.Series.IndexOf(series)}")"  Value="@Text" Position="pt" Class="@Class" />
        </g>
    ;
    }

    public bool Contains(double mouseX, double mouseY, int tolerance)
    {
        return false;
    }

    public RenderFragment RenderTooltip(double mouseX, double mouseY, double marginLeft, double marginTop)
    {
        return null;
    }
}